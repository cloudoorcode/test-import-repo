let resolveRemoteUrl;
export function setRemoteUrlResolver(_resolveRemoteUrl) {
    resolveRemoteUrl = _resolveRemoteUrl;
}
let remoteUrlDefinitions = {};
export function setRemoteDefinitions(definitions) {
    remoteUrlDefinitions = definitions;
}
export function setRemoteDefinition(remoteName, remoteUrl) {
    remoteUrlDefinitions[remoteName] = remoteUrl;
}
let remoteModuleMap = new Map();
let remoteContainerMap = new Map();
export async function loadRemoteModule(remoteName, moduleName) {
    const remoteModuleKey = `${remoteName}:${moduleName}`;
    if (remoteModuleMap.has(remoteModuleKey)) {
        return remoteModuleMap.get(remoteModuleKey);
    }
    const container = remoteContainerMap.has(remoteName)
        ? remoteContainerMap.get(remoteName)
        : await loadRemoteContainer(remoteName);
    const factory = await container.get(moduleName);
    const Module = factory();
    remoteModuleMap.set(remoteModuleKey, Module);
    return Module;
}
function loadModule(url) {
    return import(/* webpackIgnore:true */ url);
}
let initialSharingScopeCreated = false;
async function loadRemoteContainer(remoteName) {
    if (!resolveRemoteUrl && !remoteUrlDefinitions) {
        throw new Error('Call setRemoteDefinitions or setRemoteUrlResolver to allow Dynamic Federation to find the remote apps correctly.');
    }
    if (!initialSharingScopeCreated) {
        initialSharingScopeCreated = true;
        await __webpack_init_sharing__('default');
    }
    const remoteUrl = remoteUrlDefinitions
        ? remoteUrlDefinitions[remoteName]
        : await resolveRemoteUrl(remoteName);
    let containerUrl = remoteUrl;
    if (!remoteUrl.endsWith('.mjs') && !remoteUrl.endsWith('.js')) {
        containerUrl = `${remoteUrl}${remoteUrl.endsWith('/') ? '' : '/'}remoteEntry.mjs`;
    }
    const container = await loadModule(containerUrl);
    await container.init(__webpack_share_scopes__.default);
    remoteContainerMap.set(remoteName, container);
    return container;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWYuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9hbmd1bGFyL21mL21mLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQU9BLElBQUksZ0JBQTBDLENBQUM7QUFDL0MsTUFBTSxVQUFVLG9CQUFvQixDQUNsQyxpQkFBMkM7SUFFM0MsZ0JBQWdCLEdBQUcsaUJBQWlCLENBQUM7QUFDdkMsQ0FBQztBQUVELElBQUksb0JBQW9CLEdBQTJCLEVBQUUsQ0FBQztBQUN0RCxNQUFNLFVBQVUsb0JBQW9CLENBQUMsV0FBbUM7SUFDdEUsb0JBQW9CLEdBQUcsV0FBVyxDQUFDO0FBQ3JDLENBQUM7QUFFRCxNQUFNLFVBQVUsbUJBQW1CLENBQUMsVUFBa0IsRUFBRSxTQUFpQjtJQUN2RSxvQkFBb0IsQ0FBQyxVQUFVLENBQUMsR0FBRyxTQUFTLENBQUM7QUFDL0MsQ0FBQztBQUVELElBQUksZUFBZSxHQUFHLElBQUksR0FBRyxFQUFtQixDQUFDO0FBQ2pELElBQUksa0JBQWtCLEdBQUcsSUFBSSxHQUFHLEVBQW1CLENBQUM7QUFDcEQsTUFBTSxDQUFDLEtBQUssVUFBVSxnQkFBZ0IsQ0FBQyxVQUFrQixFQUFFLFVBQWtCO0lBQzNFLE1BQU0sZUFBZSxHQUFHLEdBQUcsVUFBVSxJQUFJLFVBQVUsRUFBRSxDQUFDO0lBQ3RELElBQUksZUFBZSxDQUFDLEdBQUcsQ0FBQyxlQUFlLENBQUMsRUFBRSxDQUFDO1FBQ3pDLE9BQU8sZUFBZSxDQUFDLEdBQUcsQ0FBQyxlQUFlLENBQUMsQ0FBQztJQUM5QyxDQUFDO0lBRUQsTUFBTSxTQUFTLEdBQUcsa0JBQWtCLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQztRQUNsRCxDQUFDLENBQUMsa0JBQWtCLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQztRQUNwQyxDQUFDLENBQUMsTUFBTSxtQkFBbUIsQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUUxQyxNQUFNLE9BQU8sR0FBRyxNQUFNLFNBQVMsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDaEQsTUFBTSxNQUFNLEdBQUcsT0FBTyxFQUFFLENBQUM7SUFFekIsZUFBZSxDQUFDLEdBQUcsQ0FBQyxlQUFlLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFFN0MsT0FBTyxNQUFNLENBQUM7QUFDaEIsQ0FBQztBQUVELFNBQVMsVUFBVSxDQUFDLEdBQVc7SUFDN0IsT0FBTyxNQUFNLENBQUMsd0JBQXdCLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDOUMsQ0FBQztBQUVELElBQUksMEJBQTBCLEdBQUcsS0FBSyxDQUFDO0FBQ3ZDLEtBQUssVUFBVSxtQkFBbUIsQ0FBQyxVQUFrQjtJQUNuRCxJQUFJLENBQUMsZ0JBQWdCLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO1FBQy9DLE1BQU0sSUFBSSxLQUFLLENBQ2Isa0hBQWtILENBQ25ILENBQUM7SUFDSixDQUFDO0lBRUQsSUFBSSxDQUFDLDBCQUEwQixFQUFFLENBQUM7UUFDaEMsMEJBQTBCLEdBQUcsSUFBSSxDQUFDO1FBQ2xDLE1BQU0sd0JBQXdCLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDNUMsQ0FBQztJQUVELE1BQU0sU0FBUyxHQUFHLG9CQUFvQjtRQUNwQyxDQUFDLENBQUMsb0JBQW9CLENBQUMsVUFBVSxDQUFDO1FBQ2xDLENBQUMsQ0FBQyxNQUFNLGdCQUFnQixDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBRXZDLElBQUksWUFBWSxHQUFHLFNBQVMsQ0FBQztJQUM3QixJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQztRQUM5RCxZQUFZLEdBQUcsR0FBRyxTQUFTLEdBQ3pCLFNBQVMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FDakMsaUJBQWlCLENBQUM7SUFDcEIsQ0FBQztJQUVELE1BQU0sU0FBUyxHQUFHLE1BQU0sVUFBVSxDQUFDLFlBQVksQ0FBQyxDQUFDO0lBQ2pELE1BQU0sU0FBUyxDQUFDLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUV2RCxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsVUFBVSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0lBQzlDLE9BQU8sU0FBUyxDQUFDO0FBQ25CLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgdHlwZSBSZXNvbHZlUmVtb3RlVXJsRnVuY3Rpb24gPSAoXG4gIHJlbW90ZU5hbWU6IHN0cmluZ1xuKSA9PiBzdHJpbmcgfCBQcm9taXNlPHN0cmluZz47XG5cbmRlY2xhcmUgY29uc3QgX193ZWJwYWNrX2luaXRfc2hhcmluZ19fOiAoc2NvcGU6ICdkZWZhdWx0JykgPT4gUHJvbWlzZTx2b2lkPjtcbmRlY2xhcmUgY29uc3QgX193ZWJwYWNrX3NoYXJlX3Njb3Blc19fOiB7IGRlZmF1bHQ6IHVua25vd24gfTtcblxubGV0IHJlc29sdmVSZW1vdGVVcmw6IFJlc29sdmVSZW1vdGVVcmxGdW5jdGlvbjtcbmV4cG9ydCBmdW5jdGlvbiBzZXRSZW1vdGVVcmxSZXNvbHZlcihcbiAgX3Jlc29sdmVSZW1vdGVVcmw6IFJlc29sdmVSZW1vdGVVcmxGdW5jdGlvblxuKSB7XG4gIHJlc29sdmVSZW1vdGVVcmwgPSBfcmVzb2x2ZVJlbW90ZVVybDtcbn1cblxubGV0IHJlbW90ZVVybERlZmluaXRpb25zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG5leHBvcnQgZnVuY3Rpb24gc2V0UmVtb3RlRGVmaW5pdGlvbnMoZGVmaW5pdGlvbnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4pIHtcbiAgcmVtb3RlVXJsRGVmaW5pdGlvbnMgPSBkZWZpbml0aW9ucztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldFJlbW90ZURlZmluaXRpb24ocmVtb3RlTmFtZTogc3RyaW5nLCByZW1vdGVVcmw6IHN0cmluZykge1xuICByZW1vdGVVcmxEZWZpbml0aW9uc1tyZW1vdGVOYW1lXSA9IHJlbW90ZVVybDtcbn1cblxubGV0IHJlbW90ZU1vZHVsZU1hcCA9IG5ldyBNYXA8c3RyaW5nLCB1bmtub3duPigpO1xubGV0IHJlbW90ZUNvbnRhaW5lck1hcCA9IG5ldyBNYXA8c3RyaW5nLCB1bmtub3duPigpO1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxvYWRSZW1vdGVNb2R1bGUocmVtb3RlTmFtZTogc3RyaW5nLCBtb2R1bGVOYW1lOiBzdHJpbmcpIHtcbiAgY29uc3QgcmVtb3RlTW9kdWxlS2V5ID0gYCR7cmVtb3RlTmFtZX06JHttb2R1bGVOYW1lfWA7XG4gIGlmIChyZW1vdGVNb2R1bGVNYXAuaGFzKHJlbW90ZU1vZHVsZUtleSkpIHtcbiAgICByZXR1cm4gcmVtb3RlTW9kdWxlTWFwLmdldChyZW1vdGVNb2R1bGVLZXkpO1xuICB9XG5cbiAgY29uc3QgY29udGFpbmVyID0gcmVtb3RlQ29udGFpbmVyTWFwLmhhcyhyZW1vdGVOYW1lKVxuICAgID8gcmVtb3RlQ29udGFpbmVyTWFwLmdldChyZW1vdGVOYW1lKVxuICAgIDogYXdhaXQgbG9hZFJlbW90ZUNvbnRhaW5lcihyZW1vdGVOYW1lKTtcblxuICBjb25zdCBmYWN0b3J5ID0gYXdhaXQgY29udGFpbmVyLmdldChtb2R1bGVOYW1lKTtcbiAgY29uc3QgTW9kdWxlID0gZmFjdG9yeSgpO1xuXG4gIHJlbW90ZU1vZHVsZU1hcC5zZXQocmVtb3RlTW9kdWxlS2V5LCBNb2R1bGUpO1xuXG4gIHJldHVybiBNb2R1bGU7XG59XG5cbmZ1bmN0aW9uIGxvYWRNb2R1bGUodXJsOiBzdHJpbmcpIHtcbiAgcmV0dXJuIGltcG9ydCgvKiB3ZWJwYWNrSWdub3JlOnRydWUgKi8gdXJsKTtcbn1cblxubGV0IGluaXRpYWxTaGFyaW5nU2NvcGVDcmVhdGVkID0gZmFsc2U7XG5hc3luYyBmdW5jdGlvbiBsb2FkUmVtb3RlQ29udGFpbmVyKHJlbW90ZU5hbWU6IHN0cmluZykge1xuICBpZiAoIXJlc29sdmVSZW1vdGVVcmwgJiYgIXJlbW90ZVVybERlZmluaXRpb25zKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0NhbGwgc2V0UmVtb3RlRGVmaW5pdGlvbnMgb3Igc2V0UmVtb3RlVXJsUmVzb2x2ZXIgdG8gYWxsb3cgRHluYW1pYyBGZWRlcmF0aW9uIHRvIGZpbmQgdGhlIHJlbW90ZSBhcHBzIGNvcnJlY3RseS4nXG4gICAgKTtcbiAgfVxuXG4gIGlmICghaW5pdGlhbFNoYXJpbmdTY29wZUNyZWF0ZWQpIHtcbiAgICBpbml0aWFsU2hhcmluZ1Njb3BlQ3JlYXRlZCA9IHRydWU7XG4gICAgYXdhaXQgX193ZWJwYWNrX2luaXRfc2hhcmluZ19fKCdkZWZhdWx0Jyk7XG4gIH1cblxuICBjb25zdCByZW1vdGVVcmwgPSByZW1vdGVVcmxEZWZpbml0aW9uc1xuICAgID8gcmVtb3RlVXJsRGVmaW5pdGlvbnNbcmVtb3RlTmFtZV1cbiAgICA6IGF3YWl0IHJlc29sdmVSZW1vdGVVcmwocmVtb3RlTmFtZSk7XG5cbiAgbGV0IGNvbnRhaW5lclVybCA9IHJlbW90ZVVybDtcbiAgaWYgKCFyZW1vdGVVcmwuZW5kc1dpdGgoJy5tanMnKSAmJiAhcmVtb3RlVXJsLmVuZHNXaXRoKCcuanMnKSkge1xuICAgIGNvbnRhaW5lclVybCA9IGAke3JlbW90ZVVybH0ke1xuICAgICAgcmVtb3RlVXJsLmVuZHNXaXRoKCcvJykgPyAnJyA6ICcvJ1xuICAgIH1yZW1vdGVFbnRyeS5tanNgO1xuICB9XG5cbiAgY29uc3QgY29udGFpbmVyID0gYXdhaXQgbG9hZE1vZHVsZShjb250YWluZXJVcmwpO1xuICBhd2FpdCBjb250YWluZXIuaW5pdChfX3dlYnBhY2tfc2hhcmVfc2NvcGVzX18uZGVmYXVsdCk7XG5cbiAgcmVtb3RlQ29udGFpbmVyTWFwLnNldChyZW1vdGVOYW1lLCBjb250YWluZXIpO1xuICByZXR1cm4gY29udGFpbmVyO1xufVxuIl19